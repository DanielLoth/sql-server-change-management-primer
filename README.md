# The SQL Server change management primer

## Motivation

* Learn how to work effectively with SQL Server databases, particularly with respect to minimising downtime while managing change.
* Learn how to use tools like `sqlpackage.exe` to effect that change.

## Contributing

Contributions are welcome.

Please raise pull requests for the following:
* Fixing errors (typographical and similar)
* Technical errata within existing content.

Please start a discussion first for the following:
* Whole new sections of content
  * The discussion is mostly to ensure fit within the broader primer, and to ensure that you aren't wasting time working on something that might already be in progress.

## Index of topics

* [The SqlPackage tool, SQLPROJ projects, and DACPACs](#the-sqlpackage-tool-sqlproj-projects-and-dacpacs)
  * [SqlPackage](#sqlpackage)
  * [SQLPROJ projects](#sqlproj-projects)
  * [DACPACs](#dacpacs)
* [Complexities in sqlpackage](#complexities-in-sqlpackage)
  * [Dropped and recreated CHECK constraints](#dropped-and-recreated-check-constraints)
  * [Dropped and recreated DEFAULT constraints](#dropped-and-recreated-default-constraints)
* [Manually changing data](#manually-changing-data)
* [References](#references)


## The SqlPackage tool, SQLPROJ projects, and DACPACs

### SqlPackage

The `sqlpackage` tool is best described as a desired state management tool.

It allows you to prescribe what the database *should* look like (i.e., the desired state) and - where discrepancies exist - the tool generates the necessary T-SQL queries to get the database into that desired state.

The desired state is based on a DACPAC file that you provide to the tool, as well as any command line parameters. Alternatively, a publish profile can be used to express parameters if you prefer to express them via XML file instead of at the command line.

The sqlpackage tool can operate in three modes against a database that is not registered as a `Data-tier Application`.

These modes of operation are:
* Script mode - generates a script that you can execute against the database to bring it to the desired state.
* Report mode - generates an XML report which discloses all changes that will be made in order to bring the target database to the desired state.
* Publish mode - performs the necessary changes on the database to bring it up to the desired state (i.e., in effect this involves creating the script that gets produced when running in script mode and then immediately executing it against your target database).

At the conclusion of an execution of sqlpackage running in deploy mode, you would expect a subsequent execution to make no further changes to the target database (i.e., execution of the sqlpackage deployment is idempotent if anything within your pre-deploy and post-deploy scripts is also idempotent).

### SQLPROJ projects

The `*.sqlproj` project includes one or more `*.sql` files that are compiled into a singular `*.dacpac` artifact.

The project can also include:
* A pre-deployment script, which will be included before the main deployment steps in the deployment script that gets generated by the sqlpackage tool.
* A post-deployment script that is similarly included after the main deployment steps.

### DACPACs

A DACPAC file is the artifact produced upon successfully building a SQLPROJ project.

It contains all of the necessary information about your desired database design. This includes all tables, indexes, constraints, procedures, and so on.

It also includes the aforementioned pre-deployment and post-deployment scripts.

The DACPAC file is the key input for an execution of the sqlpackage tool.

## Complexities in sqlpackage

### Dropped and recreated CHECK constraints

This happens because the definition of the constraint - as stored by SQL Server - varies from the way you've expressed that constraint within your code.

For example, consider the following table DDL and note that it uses the `CAST` function:

```sql
create table TableWithCheckConstraint (
	Id int primary key,
	constraint CK check (1 = cast(1 as int))
);
```

When you query the `sys.check_constraints` metadata view, you'll notice that SQL Server has expressed the constraint in a slightly different manner:

```sql
select
	name as ConstraintName,
	definition as ConstraintDefinition
from sys.check_constraints;
```

Results:

| ConstraintName | ConstraintDefinition
| :--- | :--- |
CK | ((1)=CONVERT([int],(1)))

To fix the issue, express your check constraint in the manner that SQL Server expresses it internally.

For example, you can resolve the issue in this example as follows:

```sql
create table TableWithCheckConstraint (
	Id int primary key,
	constraint CK check (1 = convert(int, 1))
);
```

### Dropped and recreated DEFAULT constraints

Just like CHECK constraints, SQL Server might elect to express the constraint in a manner that differs from how you've expressed it.

Consider the following table DDL which creates a table with a `BIGINT` column. The default value is a constant value, but it is a number that is too large to express as an `INT`. This means that, internally, SQL Server will express it as a `DECIMAL`.

```sql
create table TableWithDefaultConstraint (
	Col1 bigint not null
		constraint DF1 default 3000000000
);
```

When you query the `sys.default_constraints` metadata view, you'll notice a subtle difference: The `definition` column contains the number `3000000000`, but it has a period suffix at the end. In other words, the default constraint value is actually `3000000000.`.

```sql
select
	name as ConstraintName,
	definition as ConstraintDefinition
from sys.default_constraints;
```

| ConstraintName | ConstraintDefinition
| :--- | :--- |
DF1 | ((3000000000.))

This will result in a mismatch much like the dropped-and-recreated `CHECK` constraint situation.

To fix it, revise the table DDL to match.

For example:

```sql
create table TableWithDefaultConstraint (
	Col1 bigint not null
		constraint DF1 default 3000000000. /* Note the period at the end */
);
```

Or alternatively:

```sql
create table TableWithDefaultConstraint (
	Col1 bigint not null
		constraint DF1 default convert(bigint, '3000000000')
);
```

### Too much change within a single deployment

I've worked with two employers that make extensive use of the sqlpackage tool, and over time have found that people either love it or hate it.

Anecdotally, one concern raised by those who I've known to dislike it is that the tool doesn't always work.

In my experience, and with the benefit of hindsight and more experience, this is largely because the team at the time was using a Gitflow workflow and accumulating extensive amounts of change within a development branch.

The expectation, then, was that this cumlative change could all be released in one go, using a single execution of the sqlpackage tool.

### Locking and blocking

The sqlpackage tool, based on the T-SQL it generates, is clearly designed to be executed during periods of little or no database usage (i.e., during a planned outage).

This is evidenced by the fact that, by default, it will carry out tasks which involve blocking access to the data.

For example, the sqlpackage tool will happily perform table rebuilds in order to add a new column that is added between two existing columns when the `IgnoreColumnOrder` parameter has not been set to `true`.

## Manually changing data

> Sometimes you might to effect manual change. That is, a change executed by a human manually as opposed to a change executed within the context of your deployment pipeline.
>
> This is hopefully a rare occurrence. But for some businesses it's perhaps not rare at all.

### Changing small volumes of data

### Changing large volumes of data

## References

* [SqlPackage publish command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-publish?view=sql-server-ver16)
* [SqlPackage script command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-script?view=sql-server-ver16)
* [SqlPackage deploy report command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-deploy-drift-report?view=sql-server-ver16)

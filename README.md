# The SQL Server change management primer

## Motivation

* Learn how to work effectively with SQL Server databases, particularly with respect to minimising downtime while managing change.
* Learn how to use tools like `sqlpackage.exe` to effect that change.

## Contributing

Contributions are welcome.

Please raise pull requests for the following:
* Fixing errors (typographical and similar)
* Technical errata within existing content.

Please start a discussion first for the following:
* Whole new sections of content
  * The discussion is mostly to ensure fit within the broader primer, and to ensure that you aren't wasting time working on something that might already be in progress.

## Index of topics

* [The SqlPackage tool, SQLPROJ projects, and DACPACs](#the-sqlpackage-tool-sqlproj-projects-and-dacpacs)
  * [SqlPackage](#sqlpackage)
  * [SQLPROJ projects](#sqlproj-projects)
  * [DACPACs](#dacpacs)
* [SqlPackage Cookbook](#sqlpackage-cookbook)
  * [Fixing dropped and recreated CHECK constraints](#fixing-dropped-and-recreated-check-constraints)
  * [Fixing dropped and recreated DEFAULT constraints](#fixing-dropped-and-recreated-default-constraints)
  * [Avoiding blocking when creating FOREIGN KEY constraints on busy tables](#avoiding-blocking-when-creating-foreign-key-constraints-on-busy-tables)
* [Notes on locking and blocking](#notes-on-locking-and-blocking)
* [References](#references)


## The SqlPackage tool, SQLPROJ projects, and DACPACs

### SqlPackage

The `sqlpackage` tool is best described as a desired state management tool.

It allows you to prescribe what the database *should* look like (i.e., the desired state) and - where discrepancies exist - the tool generates the necessary T-SQL queries to get the database into that desired state.

The desired state is based on a DACPAC file that you provide to the tool, as well as any command line parameters. Alternatively, a publish profile can be used to express parameters if you prefer to express them via XML file instead of at the command line.

The sqlpackage tool can operate in three modes against a database that is not registered as a `Data-tier Application`.

These modes of operation are:
* Script mode - generates a script that you can execute against the database to bring it to the desired state.
* Report mode - generates an XML report which discloses all changes that will be made in order to bring the target database to the desired state.
* Publish mode - performs the necessary changes on the database to bring it up to the desired state (i.e., in effect this involves creating the script that gets produced when running in script mode and then immediately executing it against your target database).

At the conclusion of an execution of sqlpackage running in deploy mode, you would expect a subsequent execution to make no further changes to the target database (i.e., execution of the sqlpackage deployment is idempotent if anything within your pre-deploy and post-deploy scripts is also idempotent).

### SQLPROJ projects

The `*.sqlproj` project includes one or more `*.sql` files that are compiled into a singular `*.dacpac` artifact.

The project can also include:
* A pre-deployment script, which will be included before the main deployment steps in the deployment script that gets generated by the sqlpackage tool.
* A post-deployment script that is similarly included after the main deployment steps.

### DACPACs

A DACPAC file is the artifact produced upon successfully building a SQLPROJ project.

It contains all of the necessary information about your desired database design. This includes all tables, indexes, constraints, procedures, and so on.

It also includes the aforementioned pre-deployment and post-deployment scripts.

The DACPAC file is the key input for an execution of the sqlpackage tool.

## SqlPackage cookbook

### Fixing dropped and recreated CHECK constraints

This happens because the definition of the constraint - as stored by SQL Server - varies from the way you've expressed that constraint within your code.

For example, consider the following table DDL and note that it uses the `CAST` function:

```sql
create table TableWithCheckConstraint (
    Id int primary key,
    constraint CK check (1 = cast(1 as int))
);
```

When you query the `sys.check_constraints` metadata view, you'll notice that SQL Server has expressed the constraint in a slightly different manner:

```sql
select
    name as ConstraintName,
    definition as ConstraintDefinition
from sys.check_constraints;
```

Results:

| ConstraintName | ConstraintDefinition
| :--- | :--- |
CK | ((1)=CONVERT([int],(1)))

To fix the issue, express your check constraint in the manner that SQL Server expresses it internally.

For example, you can resolve the issue in this example as follows:

```sql
create table TableWithCheckConstraint (
    Id int primary key,
    constraint CK check (1 = convert(int, 1))
);
```

### Fixing dropped and recreated DEFAULT constraints

Just like CHECK constraints, SQL Server might elect to express the constraint in a manner that differs from how you've expressed it.

Consider the following table DDL which creates a table with a `BIGINT` column. The default value is a constant value, but it is a number that is too large to express as an `INT`. This means that, internally, SQL Server will express it as a `DECIMAL`.

```sql
create table TableWithDefaultConstraint (
    Col1 bigint not null
        constraint DF1 default 3000000000
);
```

When you query the `sys.default_constraints` metadata view, you'll notice a subtle difference: The `definition` column contains the number `3000000000`, but it has a period suffix at the end. In other words, the default constraint value is actually `3000000000.`.

```sql
select
    name as ConstraintName,
    definition as ConstraintDefinition
from sys.default_constraints;
```

| ConstraintName | ConstraintDefinition
| :--- | :--- |
DF1 | ((3000000000.))

This will result in a mismatch much like the dropped-and-recreated `CHECK` constraint situation.

To fix it, revise the table DDL to match.

For example:

```sql
create table TableWithDefaultConstraint (
    Col1 bigint not null
        constraint DF1 default 3000000000. /* Note the period at the end */
);
```

Or alternatively:

```sql
create table TableWithDefaultConstraint (
    Col1 bigint not null
        constraint DF1 default convert(bigint, '3000000000')
);
```

### Avoiding blocking when creating FOREIGN KEY constraints on busy tables

Consider the following scenarios, given parent table `T1` and referenced table `T2`:

* Both `T1` and `T2` are unused
  * No issues here, as you won't block other database users while creating the constraint.
* Table `T1` is used heavily, but `T2` is unused (i.e., perhaps you're adding `T2` to satisfy a new requirement)
  * No issues here: If `T1` is `Sch-M` locked first, a subsequent `Sch-M` lock on `T2` will be acquired due to lack of contention.
* Both `T1` and `T2` are used heavily (i.e., perhaps both tables are 6 months old and you've only just realised that a foreign key constraint should have been created, but was overlooked).
  * Key issue: A `Sch-M` lock is acquired on one heavily used table, and subsequently held. But getting the `Sch-M` on the second heavily used table proves challenging. All the while, the first table remains `Sch-M` locked and users are unable to transact against that data.

The SqlPackage tool doesn't generate code that is cognisant of this kind of issue.

However, you can take the following steps to reduce the risk of this issue occurring.

* Make use of a short `LOCK_TIMEOUT` and a low `DEADLOCK_PRIORITY` (set them to appropriate values within your pre-deployment script).
* Structure any pre-deployment and post-deployment code so that it is idempotent (that is, if you run it multiple times then it yields the same outcome).
* Retry the whole deployment process by re-executing the `sqlpackage.exe` tool. Either retrying until some deadline is reached (e.g.: if your first attempted deployment started at 10am, then try no further deployments after 10:10am) or some arbitrary maximum retry count is reached (e.g.: no further retries after we've already tried 5 times).

This use of `LOCK_TIMEOUT` in particular will ensure that - should a `Sch-M` lock be picked up on one busy table - it is not held indefintely (or for an extended period of time) while subsequently trying to acquire a `Sch-M` lock on a second busy table.

### Modifying an existing CHECK constraint

TODO: Cover expand-and-contract so that there is never a period of time where a constraint is left unenforced.

## Notes on locking and blocking

The sqlpackage tool, based on the T-SQL it generates, is clearly designed to be executed during periods of little or no database usage (i.e., during a planned outage).

This is evidenced by the fact that, by default, it will carry out tasks which involve blocking access to the data.

For example:
* The SqlPackage tool will happily perform table rebuilds in order to add a new column that is added between two existing columns when the `IgnoreColumnOrder` parameter has not been set to `true`.
  * This necessarily makes use of the `SERIALIZABLE` isolation level, and so is incompatible with other users of the database transacting against the data within the table for the duration of the table rebuild.
* When creating `FOREIGN KEY` constraints, the SqlPackage tool will not use any kind of blocking-avoidance strategy. For example, the `LOCK_TIMEOUT` and `DEADLOCK_PRIORITY` settings.

For a lot of companies this really isn't a problem. After all, many businesses are completely comfortable with downtime after their core business hours.

For companies running software on a 24/7 basis, this makes it all the more challenging though.

## References

* [SqlPackage publish command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-publish?view=sql-server-ver16)
* [SqlPackage script command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-script?view=sql-server-ver16)
* [SqlPackage deploy report command documentation](https://learn.microsoft.com/en-us/sql/tools/sqlpackage/sqlpackage-deploy-drift-report?view=sql-server-ver16)
